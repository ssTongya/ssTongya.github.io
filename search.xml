<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数组和对象</title>
    <url>/2019/10/10/%E6%95%B0%E7%BB%84%E5%92%8C%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>reduce 可以返回一个数组的和，如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr.reduce((total, item) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> total + item;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//10</span></span><br></pre></td></tr></table></figure>

<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter 为数组中的每个元素调用一次 callback 函数，并返回用满足条件的元素组成数组。不会改变原数组，不会对空数组进行检测</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var ages = [<span class="number">32</span>, <span class="number">33</span>, <span class="number">16</span>, <span class="number">40</span>];</span><br><span class="line">ages.filter(item =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt;= <span class="number">18</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [32, 33, 40]</span></span><br></pre></td></tr></table></figure>

<h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map 方法返回一个新数组，新数组中的元素为原始数组元素调用函数处理后的值<br>map 方法按照原始数组元素的顺序依次处理元素。不会改变原数组，不会对空数组进行检测</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">arr</span> <span class="string">=</span> <span class="string">[1,</span> <span class="number">2</span><span class="string">,</span> <span class="number">3</span><span class="string">,</span> <span class="number">4</span><span class="string">,</span> <span class="number">5</span><span class="string">];</span></span><br><span class="line"><span class="string">arr.map(item</span> <span class="string">=&gt;</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">return</span> <span class="string">item</span> <span class="string">*</span> <span class="string">item;</span></span><br><span class="line"><span class="string">&#125;);</span> <span class="string">//</span> <span class="string">[1,</span> <span class="number">4</span><span class="string">,</span> <span class="number">9</span><span class="string">,</span> <span class="number">16</span><span class="string">,</span> <span class="number">25</span><span class="string">]</span></span><br></pre></td></tr></table></figure>

<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数<br>它与 map 最大的区别就算是 map 会返回一个新的数组，并且不会影响到原数组，而 forEach 是对原数组进行一些操作，不会返回新数组；</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">arr.forEach(item =&gt; &#123;</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="comment">//3</span></span><br><span class="line"><span class="comment">//4</span></span><br></pre></td></tr></table></figure>

<h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p>返回满足条件的第一个元素。 find() 方法为数组中的每个元素都调用一次函数执行,find()方法返回第一个满足过滤方法的元素，一个都没有满足的就返回 undefined，遇到一个满足的元素后遍历就停止了<br>find() 对于空数组，函数是不会执行的。 find() 并没有改变数组的原始值。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr.find(item =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> item &gt; <span class="number">4</span>;</span><br><span class="line">&#125;); <span class="comment">//返回5</span></span><br></pre></td></tr></table></figure>

<h4 id="every"><a href="#every" class="headerlink" title="every"></a>every</h4><p>测试一个数组内所有元素是否都能通过某个指定函数的测试，它返回一个布尔值</p>
<blockquote>
<p>注意：若收到一个空数组，此方法在一切情况下都会返回 true</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">var r = arr.every((item) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line">console.log(r) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="some"><a href="#some" class="headerlink" title="some"></a>some</h4><p>试数组中是不是有元素通过了被提供的函数测试。它返回的是一个 Boolean 类型的值。</p>
<blockquote>
<p>注意：如果用一个空数组进行测试，在任何情况下它返回的都是 false。</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line">var arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">var r = arr.some((item) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> item &gt; <span class="number">3</span></span><br><span class="line">&#125;)</span><br><span class="line">console.log(r) <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>对数组的元素进行排序，并返回数组</p>
<blockquote>
<p>注意：数组已原地排序，并且不进行复制。</p>
</blockquote>
<blockquote>
<p>原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。</p>
</blockquote>
<figure class="highlight arcade"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">100</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">300</span>, <span class="number">150</span>, <span class="number">201</span>]</span><br><span class="line"><span class="keyword">var</span> arr2 = arr1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a - b; <span class="comment">//升序</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> arr3 = arr1.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b - a;<span class="comment">//降序</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="for…of"><a href="#for…of" class="headerlink" title="for…of"></a>for…of</h4><p>for…of 是 ES6 作为遍历所有数据结构的统一的方法。</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><span class="line">循环数组</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">//分别输出a b c   切记！！！循环读取的是键值，也就是当前值，不是索引值！！！！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">循环字符串</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">string</span> = <span class="string">'baz'</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> <span class="built_in">string</span>)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i)  <span class="comment">//分别输出b a z</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h4><p>遍历对象</p>
<blockquote>
<p>for…in 不应该用于迭代一个 Array，因为 for…in 将以任何特定的顺序返回索引，可用 forEach()或者 for…of 循环</p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line">var obj = &#123; x: <span class="number">100</span>, y: <span class="number">200</span>, z: <span class="number">300</span> &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">key</span> in obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(<span class="built_in">key</span>)) &#123;</span><br><span class="line">        console.<span class="built_in">log</span>(<span class="built_in">key</span> + <span class="string">'='</span> + obj[<span class="built_in">key</span>])   <span class="comment">//循环读取的是键名，不是键值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// x=100</span></span><br><span class="line"><span class="comment">// y=200</span></span><br><span class="line"><span class="comment">// z=300</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>hasOwnProperty：会返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>TypeScript</title>
    <url>/2019/07/07/TypeScript/</url>
    <content><![CDATA[<p>前些日子才知道有 TypeScript 这个语言，有时候真的觉得自己孤陋寡闻，看来还是要多看多学习啊。以下记录一下此语言的语法：</p>
<blockquote>
<p>TypeScript 是 JavaScript 的一个超集，扩展了 JavaScript 语法<br>它支持 ES6，它可以编译成 JavaScript；</p>
</blockquote>
<h4 id="一、定义变量"><a href="#一、定义变量" class="headerlink" title="一、定义变量"></a>一、定义变量</h4><h5 id="1-基本数据类型的变量-数据类型"><a href="#1-基本数据类型的变量-数据类型" class="headerlink" title="1. 基本数据类型的变量:数据类型"></a>1. 基本数据类型的变量:数据类型</h5><p><strong>数字和字符串</strong></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> text:<span class="built_in">string</span> = <span class="string">'芒果西米露'</span>  <span class="comment">//字符串</span></span><br><span class="line"><span class="keyword">let</span> age:<span class="built_in">number</span> = <span class="number">12</span>    <span class="comment">//数字</span></span><br><span class="line"><span class="keyword">let</span>  sentence:<span class="built_in">string</span> = <span class="string">`hello,my favorite food is <span class="subst">$&#123;text&#125;</span>`</span>  <span class="comment">//模板字符串</span></span><br></pre></td></tr></table></figure>

<p>当然也可以在 TypeScript 直接定义变量，不用定义数据类型；因为 TypeScript 是 JavaScript 的扩展，它支持任何 JavaScript 的语法。<br>如果在赋值的时候值的类型与预设的类型不一致的话，会报错，假如将上例<code>let age:number = 12</code>写成<code>let age:number = &#39;12&#39;</code>,运行代码的就会报错<code>Type &#39;&quot;12&quot;&#39; is not assignable to type &#39;number&#39;</code>.<br><strong>布尔值</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">let <span class="string">isBoolean:</span> <span class="keyword">boolean</span> = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>

<p>但是，使用构造函数创造的对象不是布尔值，而是 Boolean 对象</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isBoolean: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);  <span class="comment">//[Boolean: true]</span></span><br></pre></td></tr></table></figure>

<p>直接调用 Boolean 也可以返回一个 boolean 类型</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">直接调用<span class="keyword">Boolean</span>也可以返回一个<span class="keyword">boolean</span>类型</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 TypeScript 中，boolean 是 JavaScript 中的基本类型，而 Boolean 是 JavaScript 中的构造函数。其他基本类型（除了 null 和 undefined）一样<br><strong>空值</strong><br>空值一般用在没有任何返回值的函数</p>
</blockquote>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFn</span><span class="params">()</span>: void </span>&#123;</span><br><span class="line">    console.log(<span class="string">'this is test'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一个 void 类型的变量时，值只能时 null 或 undefined</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">声明一个<span class="keyword">void</span>类型的变量时，值只能时<span class="literal">null</span>或<span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>null 和 undefined</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> nullValue1:<span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> nullValue2:<span class="literal">null</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uValue1:<span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> uValue2:<span class="literal">undefined</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> erroV1:<span class="literal">null</span> = <span class="number">12</span> <span class="comment">//Error</span></span><br><span class="line"><span class="keyword">let</span> erroV2:<span class="literal">undefined</span> = <span class="number">12</span> <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<p>由此可见，null 和 undefined 可以互相赋值，不能被赋予其他类型的值。<br>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 和 null 可以赋值给其他类型的变量，但是 void 不可以</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> test1:<span class="built_in">number</span> = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> test2:<span class="built_in">boolean</span> = <span class="literal">undefined</span></span><br><span class="line"><span class="keyword">let</span> u:<span class="built_in">void</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> test3:<span class="built_in">string</span> = u <span class="comment">//Error</span></span><br></pre></td></tr></table></figure>

<h5 id="2-数组-变量-数据类型-或者-变量-Array-lt-数据类型-gt-表示由此类型的元素组成数组"><a href="#2-数组-变量-数据类型-或者-变量-Array-lt-数据类型-gt-表示由此类型的元素组成数组" class="headerlink" title="2. 数组 变量:数据类型[] 或者 变量:Array&lt;数据类型&gt; 表示由此类型的元素组成数组"></a>2. 数组 变量:数据类型[] 或者 变量:Array&lt;数据类型&gt; 表示由此类型的元素组成数组</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1: <span class="built_in">number</span>[] = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> arr2: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt; = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>

<p>这样写的话数组中的每个元素的类型都只能是预设的数据类型,很无奈吧</p>
<h5 id="3-元组-元组类型允许表示一个已知元素数量和类型的数组。"><a href="#3-元组-元组类型允许表示一个已知元素数量和类型的数组。" class="headerlink" title="3.元组 元组类型允许表示一个已知元素数量和类型的数组。"></a>3.元组 元组类型允许表示一个已知元素数量和类型的数组。</h5><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> touple: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">1</span>, <span class="string">'2'</span>]  <span class="comment">//这样是ok的</span></span><br><span class="line"><span class="keyword">let</span> touple: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="string">'1'</span>,<span class="number">2</span>]   <span class="comment">//这样是会报错的</span></span><br><span class="line"><span class="keyword">let</span> touple: [<span class="built_in">number</span>, <span class="built_in">string</span>] = [<span class="number">2</span>]   <span class="comment">//这样是会报错的  (直接赋值需要提供所有的元素)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> touple: [<span class="built_in">number</span>, <span class="built_in">string</span>];</span><br><span class="line">touple[<span class="number">0</span>] = <span class="number">12</span>;<span class="comment">//ok</span></span><br><span class="line">touple[<span class="number">1</span>] = <span class="string">'34'</span>;<span class="comment">//ok</span></span><br></pre></td></tr></table></figure>

<p>也就是说，虽然元组可以允许定义不同类型的变量，但是它竟然要预设的类型的顺序和元素的顺序也要一样，一一对应。但是当用 push 或者 unshift 增加元素时，会使用联合类型代替，也就是数据类型是 number 或者 string 都可以</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">touple</span><span class="selector-class">.unshift</span>(<span class="string">'3'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数组合并了相同类型的对象，而元组（Tuple）合并了不同类型的对象。</p>
</blockquote>
<h5 id="4-任意值"><a href="#4-任意值" class="headerlink" title="4.任意值"></a>4.任意值</h5><p>普通类型的值在赋值的过程中值的类型是不能改变的，但是如果是 any 类型，就可以被赋值为任意类型</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">let test:number = 10;</span><br><span class="line"><span class="keyword">test </span>= '啦啦啦' //error</span><br><span class="line"></span><br><span class="line">let anyValue:any = 10;</span><br><span class="line">anyValue = '10' //ok</span><br></pre></td></tr></table></figure>

<p>如果在定义变量时未定义类型未赋值，都会被推断成 any 类型</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">let</span> anyValue;</span><br><span class="line"><span class="attribute">anyValue</span> = <span class="number">12</span>;</span><br><span class="line"><span class="attribute">anyValue</span> = <span class="string">'12'</span></span><br></pre></td></tr></table></figure>

<p>如果在定义变量时未定义类型但赋值，则会被默认成赋值的类型</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">let anyValue</span> = <span class="string">'12'</span>;</span><br><span class="line"><span class="attribute">anyValue</span> = 12 //error</span><br></pre></td></tr></table></figure>

<p>等价于</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anyValue:<span class="keyword">string</span> = <span class="string">'12'</span>;</span><br><span class="line">anyValue = <span class="number">12</span></span><br></pre></td></tr></table></figure>

<h5 id="5-联合类型"><a href="#5-联合类型" class="headerlink" title="5.联合类型"></a>5.联合类型</h5><p>联合类型允许变量不必只能是一种类型，只要是其中一个类型就可以</p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">value</span>: number | <span class="keyword">string</span>;</span><br><span class="line"><span class="keyword">value</span> = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">value</span> = <span class="string">'456'</span>;</span><br><span class="line"><span class="keyword">value</span> = ture  <span class="comment">//error</span></span><br></pre></td></tr></table></figure>

<p><strong>联合类型的属性和方法</strong></p>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">getLength</span>(<span class="params"><span class="keyword">params</span>: number | <span class="keyword">string</span></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">params</span>.length</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错 因为number类型不具有length属性</span></span><br></pre></td></tr></table></figure>

<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> get<span class="constructor">Length(<span class="params">params</span>: <span class="params">number</span> | <span class="params">string</span>)</span> &#123;</span><br><span class="line">    return params.<span class="keyword">to</span><span class="constructor">String()</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错 因为toString 是number和string都有toString()属性，</span></span><br></pre></td></tr></table></figure>

<h4 id="二-接口"><a href="#二-接口" class="headerlink" title="二.接口"></a>二.接口</h4><p>我们可以使用接口自己定义对象的定义规则</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="symbol">Husband</span> &#123;</span><br><span class="line">    sex: <span class="built_in">string</span>;</span><br><span class="line">    <span class="built_in">int</span>erest: number;</span><br><span class="line">&#125;</span><br><span class="line">let myHusband: Husband = &#123; sex: <span class="string">'男'</span>, <span class="built_in">int</span>erest: <span class="number">123</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>以上，我们定义了 Husband 接口，包含有两个变量，一个是 string 类型，一个是 number 类型，这样，我们就约束了 myHusband 这个对象的规则。一般，接口的首字母用大写。<br>以下两种方式是不被允许的</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="symbol">Husband</span> &#123;</span><br><span class="line">    sex: <span class="built_in">string</span>;</span><br><span class="line">    <span class="built_in">int</span>erest: number;</span><br><span class="line">&#125;</span><br><span class="line">let myHusband: Husband = &#123;name:<span class="string">'许嵩'</span>, sex: <span class="string">'男'</span>, <span class="built_in">int</span>erest: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="comment">//error  多了一些属性是不被允许的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="symbol">Husband</span> &#123;</span><br><span class="line">    sex: <span class="built_in">string</span>;</span><br><span class="line">    <span class="built_in">int</span>erest: number;</span><br><span class="line">&#125;</span><br><span class="line">let myHusband: Husband = &#123;<span class="built_in">int</span>erest: <span class="number">123</span> &#125;;</span><br><span class="line"><span class="comment">//error  少了一些属性也是不被允许的</span></span><br></pre></td></tr></table></figure>

<p><strong>可选属性</strong><br>可选属性就是该属性可有可无。当一些属性是选填的时候，我们可以使用可选属性</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="symbol">Husband</span> &#123;</span><br><span class="line">    sex?: <span class="built_in">string</span>;</span><br><span class="line">    <span class="built_in">int</span>erest: number;</span><br><span class="line">&#125;</span><br><span class="line">let myHusband: Husband = &#123; <span class="built_in">int</span>erest: <span class="number">123</span> &#125;;</span><br></pre></td></tr></table></figure>

<p><strong>只读属性</strong><br>只读属性只能在创建的时候被赋值，之后赋值就会报错，使用 readonly 来定义</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Husband</span> &#123;</span></span><br><span class="line">    readonly <span class="string">sex:</span> string;</span><br><span class="line"><span class="symbol">    interest:</span> number;</span><br><span class="line">&#125;</span><br><span class="line">let <span class="string">myHusband:</span> Husband = &#123;<span class="string">sex:</span><span class="string">'男'</span>, <span class="string">interest:</span> <span class="number">123</span> &#125;;<span class="comment">//在创建的时候定义了sex属性</span></span><br><span class="line">myHusband.sex = <span class="string">'女'</span> <span class="comment">//error 不可更改</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="symbol">Husband</span> &#123;</span><br><span class="line">    readonly sex: <span class="built_in">string</span>;</span><br><span class="line">    <span class="built_in">int</span>erest: number;</span><br><span class="line">&#125;</span><br><span class="line">let myHusband: Husband = &#123;<span class="built_in">int</span>erest: <span class="number">123</span> &#125;;<span class="comment">//error 因为在给myHusband赋值的时候，没有给sex赋值</span></span><br></pre></td></tr></table></figure>

<h4 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h4><p>我们可以用 typescript 对函数的参数和返回值进行约束</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">function testFn(age: <span class="built_in">number</span>, <span class="built_in">name</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line"><span class="built_in">    return</span> `hi,<span class="keyword">my</span> <span class="built_in">name</span> <span class="keyword">is</span> $&#123;<span class="built_in">name</span>&#125;,I'm $&#123;age&#125; years old.`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中()中是对各个参数的约束，()后紧跟的就是返回值的类型<br><strong>可选参数</strong></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">function testFn(<span class="built_in">name</span>: <span class="built_in">string</span>,age?: <span class="built_in">number</span>, ): <span class="built_in">string</span> &#123;</span><br><span class="line"><span class="built_in">    return</span> `hi,<span class="keyword">my</span> <span class="built_in">name</span> <span class="keyword">is</span> $&#123;<span class="built_in">name</span>&#125;,I'm $&#123;age&#125; years old.`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，<strong>可选参数必须跟在必填参数的后面</strong> &gt; <strong>参数默认值</strong></p>
</blockquote>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">function testFn(<span class="built_in">name</span>: <span class="built_in">string</span>, age: <span class="built_in">number</span> = <span class="number">12</span>, ): <span class="built_in">string</span> &#123;</span><br><span class="line"><span class="built_in">    return</span> `hi,<span class="keyword">my</span> <span class="built_in">name</span> <span class="keyword">is</span> $&#123;<span class="built_in">name</span>&#125;,I'm $&#123;age&#125; years old.`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，因为平时也没用过 typescript 就先学到了这个，等以后再继续补充</p>
]]></content>
  </entry>
  <entry>
    <title>JS判断数据类型</title>
    <url>/2019/10/23/JS%E5%88%A4%E6%96%AD%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>JS 中判断数据类型通常使用的有三种，分别为 typeof，instanceof 和 Object.prototype.toString.call()，不过它们各自有各自的适用条件</p>
<h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><blockquote>
<p>MDN 名词解释：typeof 操作符返回一个字符串，表示未经计算的操作数的类型。</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">typeof</span><span class="params">(<span class="number">123</span>)</span></span>      <span class="comment">//"number"</span></span><br><span class="line"><span class="function"><span class="title">typeof</span><span class="params">(<span class="string">'123'</span>)</span></span>    <span class="comment">//"string"</span></span><br><span class="line"><span class="function"><span class="title">typeof</span><span class="params">(false)</span></span>    <span class="comment">//"boolean"</span></span><br><span class="line"><span class="function"><span class="title">typeof</span><span class="params">(function a()</span></span>&#123;&#125;)   <span class="comment">//"function"</span></span><br><span class="line"><span class="function"><span class="title">typeof</span><span class="params">(undefined)</span></span>    <span class="comment">//"undefined"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">typeof</span><span class="params">(null)</span></span>         <span class="comment">//"object"</span></span><br><span class="line"><span class="function"><span class="title">typeof</span><span class="params">([])</span></span>           <span class="comment">//"object"</span></span><br><span class="line"><span class="function"><span class="title">typeof</span><span class="params">(&#123;&#125;)</span></span>           <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure>

<p>可见 typeof 对基础类型都是可以检测出来的，但是对于 <strong>null，Array，Object 返回的都是”object”</strong>。这可能就不能满足我们的需求了<br>但是! 既然 null 属于基本数据类型，为什么 typeof null 返回的是’object’呢,这其实是语言本身的一个 bug。<em>（原理：不同的对象在底层都表示为二进制，在 JavaScript 中二进制钱三位都为 0 的话会被判断为 object 类型，null 的二进制表示全是 0，自然前三位也是 0，所以执行 typeof 会返回’object’）</em><br>接下来再看 instanceof</p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><blockquote>
<p>MDN 名词解释：instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line"><span class="number">123</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>                  <span class="comment">//false</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>)) <span class="keyword">instanceof</span> <span class="built_in">Number</span>    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="string">'123'</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>                <span class="comment">//false</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'123'</span>)) <span class="keyword">instanceof</span> <span class="built_in">String</span>  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">instanceof</span> <span class="built_in">Array</span>                <span class="comment">//true</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Array</span>()) <span class="keyword">instanceof</span> <span class="built_in">Array</span>          <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span></span><br><span class="line">(&#123;<span class="attr">a</span>:<span class="number">1</span>,<span class="attr">b</span>:<span class="number">2</span>&#125;) <span class="keyword">instanceof</span> <span class="built_in">Object</span>           <span class="comment">//true</span></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Object</span>()) <span class="keyword">instanceof</span> <span class="built_in">Object</span>        <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>首先，instanceof 检测的变量类型必须为对象，而第二行和第六行的检测的是一个基础类型，而不是对象，所以用 instanceof 检测返回的结果就是 false 了。<br>既然是基础类型，为什么数字类型的变量可以用 toFixed 等方法呢？是因为 js 引擎在必要的时候，会对基本数据类型进行“封箱”操作，把基本类型转化成对应的复杂对象类型，所以数字类型才可以使用 toFixed()方法，字符类型才可以使用 charAt()方法<br>所以说 instanceof 也是有缺陷的</p>
<h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Object</span>.prototype.toString.<span class="keyword">call</span>(<span class="number">123</span>)                    //"[object Number]"</span><br><span class="line"><span class="keyword">Object</span>.prototype.toString.<span class="keyword">call</span>(<span class="built_in">new</span> Number(<span class="number">123</span>))        //"[object Number]"</span><br><span class="line"><span class="keyword">Object</span>.prototype.toString.<span class="keyword">call</span>(<span class="string">'啦啦啦'</span>)                //"[object String]"</span><br><span class="line"><span class="keyword">Object</span>.prototype.toString.<span class="keyword">call</span>(<span class="built_in">new</span> String(<span class="string">'啦啦啦'</span>))    //"[object String]"</span><br><span class="line"><span class="keyword">Object</span>.prototype.toString.<span class="keyword">call</span>(<span class="keyword">false</span>)                   //"[object Boolean]"</span><br><span class="line"><span class="keyword">Object</span>.prototype.toString.<span class="keyword">call</span>(<span class="keyword">null</span>)                    //"[object Null]"</span><br><span class="line"><span class="keyword">Object</span>.prototype.toString.<span class="keyword">call</span>(undefined)               //"[object Undefined]"</span><br><span class="line"><span class="keyword">Object</span>.prototype.toString.<span class="keyword">call</span>([])                      //"[object Array]"</span><br><span class="line"><span class="keyword">Object</span>.prototype.toString.<span class="keyword">call</span>(&#123;&#125;)                      //"[object Object]"</span><br><span class="line"><span class="keyword">Object</span>.prototype.toString.<span class="keyword">call</span>(<span class="keyword">function</span> a()&#123;&#125;)          //"[object Function]"</span><br></pre></td></tr></table></figure>

<p>很明显，此方法可以检测基础类型和复杂类型，简直完美到不行！！！<br>Object.prototype.toString.call()返回的是一个字符串类型的数据，我们可以对此数据进行截取得到我们想要的结果，就大功告成啦</p>
]]></content>
  </entry>
  <entry>
    <title>vue插件集合</title>
    <url>/2019/11/07/vue%E6%8F%92%E4%BB%B6%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<p>在此记录在项目中使用过或者自己觉得好用的插件，基本上附有 github 地址，也方便以后直接使用。</p>
<h4 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h4><p><a href="https://github.com/JdesEva/vue-editor-interline/" target="_blank" rel="noopener">富文本 github 网址</a></p>
<h4 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h4><p><a href="https://github.com/hilongjw/vue-lazyload" target="_blank" rel="noopener">图片懒加载 github 网址</a></p>
<h4 id="v-charts"><a href="#v-charts" class="headerlink" title="v-charts"></a>v-charts</h4><p><a href="https://v-charts.js.org/#/" target="_blank" rel="noopener">v-charts</a></p>
<h4 id="剪切板"><a href="#剪切板" class="headerlink" title="剪切板"></a>剪切板</h4><p><a href="https://www.npmjs.com/package/vue-clipboard2" target="_blank" rel="noopener">剪切板</a></p>
]]></content>
  </entry>
  <entry>
    <title>ES6</title>
    <url>/2019/11/13/ES6/</url>
    <content><![CDATA[<h4 id="一、模块化"><a href="#一、模块化" class="headerlink" title="一、模块化"></a>一、模块化</h4><h5 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抛出(default.js)</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'this is export default'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引入(index.js)</span></span><br><span class="line"><span class="keyword">import</span> myfn form <span class="string">'default'</span></span><br></pre></td></tr></table></figure>

<p>使用 export default 时，对应的 import 语句不需要使用大括号，并且允许你取任意名称。本质上 export default 就是输出一个叫做 default 的变量或方法，很显然，一个模块只能有一个 export default</p>
<h5 id="export"><a href="#export" class="headerlink" title="export"></a>export</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//抛出(export.js)</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'util2 fn1'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'util2 fn2'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//引入(index.js)</span></span><br><span class="line"><span class="keyword">import</span> &#123;fn1,fn2&#125; form <span class="string">'export'</span>      <span class="comment">//引入方法1</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> common form <span class="string">'export'</span>    <span class="comment">//引入方法2</span></span><br></pre></td></tr></table></figure>

<p>使用 export 可以抛出多个变量，一个模块中可以有多个；方法 1 可指定加载某个输出值，方法 2 是整体加载的写法，即用*指定一个对象，所有的输出值都加载在这个对象上面</p>
]]></content>
  </entry>
  <entry>
    <title>Vue监听数组变化</title>
    <url>/2019/11/23/Vue%E7%9B%91%E5%90%AC%E6%95%B0%E7%BB%84%E5%8F%98%E5%8C%96/</url>
    <content><![CDATA[<p>上次接到一个面试电话 📞，直接就问 Vue 通过索引改变数组，视图层为什么监听不到？一下子把我问懵了，我只知道视图层监听不到通过索引和 length 改变数组，但是不知道是什么原因，下来赶紧看了一下，以下就是我得到的答案。</p>
<p>首先，Vue 是使用 Object.defineProperty 中的存取描述符 getter/setter（Object.defineProperty 是 ES5 中一个<br>无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因）来监听对象属性的添加和修改的，从而实现响应式的<br>如以下例子：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">var person = &#123;&#125;, <span class="keyword">temp</span> = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">Object</span>.defineProperty(person, <span class="string">'name'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: <span class="keyword">function</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">temp</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: <span class="keyword">function</span> (val) &#123;</span><br><span class="line">        <span class="keyword">temp</span> = val;</span><br><span class="line">        console.log(<span class="string">'触发了set'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">person.name = <span class="string">'蛋挞'</span>;    //触发了<span class="keyword">set</span></span><br><span class="line">person.name = <span class="string">'巧克力'</span>;  //触发了<span class="keyword">set</span></span><br></pre></td></tr></table></figure>

<p>以上例子是给 person 添加了 name 属性，每次给 name 重新赋值都可以监听到变化，并且属性值是字符串。再来看看如果添加的是数组的话是什么样子的</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">var person = &#123;&#125;, <span class="keyword">temp</span> = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">Object</span>.defineProperty(person, <span class="string">'myBook'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: <span class="keyword">function</span> () &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">temp</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: <span class="keyword">function</span> (val) &#123;</span><br><span class="line">        <span class="keyword">temp</span> = val;</span><br><span class="line">        console.log(<span class="string">'触发了set'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">person.myBook = [<span class="string">'瓦尔登湖'</span>, <span class="string">'我们仨'</span>]  //触发了<span class="keyword">set</span></span><br><span class="line">person.myBook = [<span class="string">'1'</span>, <span class="string">'2'</span>]             //触发了<span class="keyword">set</span></span><br><span class="line">person.myBook.push(<span class="string">'3'</span>)</span><br><span class="line">person.myBook.unshift(<span class="string">'0'</span>)</span><br><span class="line">person.myBook.pop()</span><br><span class="line">person.myBook.shift()</span><br><span class="line">person.myBook.splice(<span class="number">0</span>, <span class="number">0</span>, <span class="string">'4'</span>)</span><br><span class="line">person.myBook.sort()</span><br><span class="line">person.myBook.reverse()</span><br><span class="line">person.myBook[<span class="number">0</span>] = <span class="string">'3'</span></span><br><span class="line">console.log(person.myBook)           //["3", "2", "1"]</span><br></pre></td></tr></table></figure>

<p>由此可见，除了直接改变数组，后面几种都没有触发 set。其实数组的元素是变化了的，只是没有触发 set 而已。而在 vue 中我们却可以愉快的使用 <strong>push、pop、unshift、shift、splice、sort、reverse</strong> 这七种方法，并且都是响应式的，是因为 vue 源码对这七种方法进行了重写，才使得我们可以响应式的使用这七种方法。但是为什么 vue 没有重写索引修改数组，我想，大概是因为索引这种方法它没有具体的键值，没法对它进行重写，并且通常使用数组是用来遍历的，如果对索引方法进行 setter 开销也是很大的。</p>
<p><strong>对于不能监听的数据，vue 提供了解决方法</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="module-access"><span class="module"><span class="identifier">Vue</span>.</span></span>set(对象，键名，新值)</span><br><span class="line">vm.<span class="constructor">$set(对象，键名，新值)</span></span><br></pre></td></tr></table></figure>

<p>栗子：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">var <span class="keyword">vm</span> = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  dat<span class="variable">a:</span> &#123;</span><br><span class="line">    item<span class="variable">s:</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">vm</span>.<span class="built_in">items</span>[<span class="number">1</span>] = <span class="string">'x'</span>      // 不是响应性的</span><br><span class="line"><span class="keyword">vm</span>.<span class="built_in">items</span>.length = <span class="number">2</span>    // 不是响应性的</span><br><span class="line"></span><br><span class="line">//可以使用</span><br><span class="line">Vue.<span class="keyword">set</span>(<span class="built_in">items</span>,<span class="number">1</span>,<span class="string">'x'</span>)   //item<span class="variable">s:</span>[<span class="string">'a'</span>,<span class="string">'x'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="keyword">vm</span>.$<span class="keyword">set</span>(<span class="built_in">items</span>,<span class="number">1</span>,<span class="string">'x'</span>)   //item<span class="variable">s:</span>[<span class="string">'a'</span>,<span class="string">'x'</span>,<span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
